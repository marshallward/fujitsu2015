<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>MOM Overview</title>

    <meta name="description" content="An overview of the Modular Ocean Model">
    <meta name="author" content="Marshall Ward">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">
    <!--<link rel="stylesheet" href="lib/css/solarized_dark.css"> -->

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal"
         style="background: url(figures/nci/bg_nci.png);
                background-size: cover;">

      <header style="width: 10%; position: absolute; top: 2%; left: 2%;">
        <img src="figures/nci/nci_logo_small.png" alt="NCI">
      </header>

      <!--
      <footer style="position: absolute; bottom: 2%; right: 2%;">
          <code>nci.org.au</code>
      </footer>
      -->

      <div class="slides">

        <section>
          <div class="reveal" style="text-align: right;">
            <img src="figures/nci/nci_logo.png"
                 style="background:none; border:none; box-shadow:none;
                        width: 30%;"
                 alt="NCI">
          </div>

          <h3 style="text-align: left; color: white;">
            An Overview of MOM
          </h3>

          <p style="text-align: right;">Marshall Ward
            <br>National Computational Infrastructure
          </p>
        </section>

        <section>
          <h3>MOM summary</h3>
          <p>Geophysical Fluid Dynamics Laboratory (GFDL)</p>
          <ul>
            <li>Bryan-Cox model</li>
              <ul>
                <li>Hydrostatic Boussinesq dynamics</li>
                <li>Horizontal finite difference solver</li>
                <li>Vertical convective adjustment</li>
                <li>Arakawa B-grid for nonlinear conservation</li>
                <li>Viscous parameterisation of turbulence</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>History of MOM</h3>
          <dl>
            <dt>1984: "Cox code"</dt>
              <dd>First public release</dd>
            <dt>1991: MOM 1</dd>
              <dd>Fortran 77, POP fork</dd>
            <dt>1996: MOM 2</dt>
              <dd>"Memory window" parallelisation</dd>
            <dt>1999: MOM 3</dt>
            <dd>Explicit free surface (no elliptic solver)</dd>
            <dt>2004: MOM 4</dt>
              <dd>Domain decomposition (HIM), generalised grids</dd>
            <dt>2012: MOM 5</dt>
              <dd>Public, open source release</dd>
          </dl>
        </section>

        <section>
          <h3>Basic equations of motion</h3>
          <p>Mostly a hyperbolic PDE with constraints</p>
          $$
          \begin{align}
            p_z &= -g \rho \\
            \mathbf{u}_t + \mathbf{u} \cdot \nabla \mathbf{u} + w \mathbf{u}_z
              + f \hat{z} \times \mathbf{u}
              &= -\tfrac{1}{\rho} \nabla p + \mathcal{F} \\
            \phi_t + \mathbf{u} \cdot \nabla \phi + w \phi_z
              &= \mathcal{F}_\phi \ (\phi \in T, S, \ldots) \\
            \nabla \cdot \mathbf{u} + w_z &= 0 \\
            f(\rho, T, S, ...) &= 0
          \end{align}
          $$
          <p>But there are a lot of additional terms and forcings</p>
        </section>

        <section>
          <h3>FMS: Flexible Modeling System</h3>
          <p>Framework for MOM and SIS development</p>
          <ul>
            <li>Abstraction of common operations
              <ul>
                <li>Communication (MPI, SHMEM, serial)</li>
                <li>Diagnostics</li>
                <li>IO (NetCDF)</li>
                <li>Coupler field exchange</li>
                <li>Time and calendar management</li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- Basics -->

        <section>
          <h2>Principles of MOM</h2>
        </section>

        <section>
          <h3>Arakawa grids</h3>
          <img src="figures/arakawa.svg" alt="Arakawa grids"
               style="background: white; border: none; box-shadow: none;">
          <p>MOM is a B-grid model</p>
          <p>"Northeast convention": $U(i,j)$ is northeast of $T(i,j)$</p>
        </section>

        <section>
          <h3>Generalised orthogonal coordinates</h3>
          <img src="figures/gfdl_tripole.svg" alt="Orthographic tripolar"
               style="background: none; border: none; box-shadow: none;">
          <p>Generalised grids require $\Delta x$ arrays</p>
        </section>

        <section>
          <h3>Split timestepping</h3>
          <p>Ocean stratification yields <i>fast</i> and <i>slow</i> dynamics:
          $$\begin{align}
            \mathbf{u} &=
            \left\{ \frac{1}{H} \int_{-H}^\eta \mathbf{u} \right\}
            + \left\{ \mathbf{u}
            - \frac{1}{H} \int_{-H}^\eta \mathbf{u} \right\} \\
            &= \mathbf{U} + \mathbf{u}'
          \end{align}$$
          <ul>
            <li>Depth-averaged dynamics is ~100x faster</li>
            <li>Accuracy less important; simpler solvers</li>
            <li>Additional filtering required</li>
          </ul>
        </section>

        <section>
          <h3>$z^*$ vertical grid</h3>
          <p>Ocean surface-following coordinates</p>
          <p>
          $z^* = H \left( \frac{z - \eta}{H + \eta} \right)$
          <img src="figures/zstar.gif" style="float: right">
          <ul>
            <li>No initial spontaneous flow</li>
            <li>Simpler neutral physics parameterisations</li>
            <li>Always non-vanishing (except $\eta > -H$)</li>
          </ul>
        </section>

        <!-- Build -->

        <section>
          <h3>Building MOM</h3>
        </section>

        <section>
          <h3>MOM community</h3>
          <p>The official MOM website:</p>
          <h3><a href="http://www.mom-ocean.org/">
              http://www.mom-ocean.org</a></h3>
          <p>and the mailing list:</p>
          <h3><a href="https://groups.google.com/forum/#!forum/mom-users">
              https://groups.google.com/forum/#!forum/mom-users</a></h3>
        </section>

        <section>
          <h3>MOM source</h3>
          <p>MOM is publicly available and hosted on github:</p>
          <pre><code data-trim class="sh">
git clone https://github.com/BreakawayLabs/mom.git
          </code></pre>
          <ul>
            <li>Scientific maintainer: Stephen Griffies (GFDL)</li>
            <li>Repository maintainer: Nicholas Hannah (UNSW)</li>
          </ul>
        </section>

        <section>
          <h3>MOM codebase</h3>
          <dl>
            <dt><code>bin/</code></dt>
            <dd>Platform configuration</dd>
            <dt><code>data/</code></dt>
            <dd>Dataset management</dd>
            <dt><code>doc/</code></dt>
            <dd>Documentation</dd>
            <dt><code>exp/</code></dt>
            <dd>Compile and run scripts</dd>
            <dt><code>src/</code></dt>
            <dd>Model sourcecode</dd>
            <dt><code>test/</code></dt>
            <dd>Test and verification suites<dd>
          </dl>
        </section>

        <section>
          <h3>MOM drivers</h3>
          <dl>
            <dt>MOM_solo</dt>
            <dd>Ocean-only
              <br>(<code>src/mom5/drivers/ocean_solo.F90</code>)</dd>
            <dt>MOM_SIS</dt>
            <dd>Ocean-Sea Ice
              <br>(<code>src/coupler/coupler_main.F90</code>)</dd>
            <dt>CM2M</dt>
            <dd>GFDL CM2 coupled model</dd>
            <dt>ACCESS-CM</dt>
            <dd>ACCESS coupled climate model</dd>
          </dl>
        </section>

        <section>
          <h3>Build configuration</h3>
          <p>Makefiles are generated by GFDL's <code>mkmf</code> tool.
          <dl>
            <dt><code>environs.&lt;platform&gt;</code></dt>
            <dd>Software stack (e.g. modules)</dd>
            <dt><code>mkmf.template.&lt;platform&gt;</code></dt>
            <dd>Compiler settings and flags</dd>
          </dl>
          <p>We use the <code>nci</code> platform</p>
        </section>

        <section>
          <h3><code>environs.nci</code></h3>
          <pre><code data-trim class="csh">
source /etc/profile.d/nf_csh_modules
module purge
module load intel-fc/15.0.3.187
module load intel-cc/15.0.3.187
module load netcdf/4.3.3.1
module load openmpi/1.8.8-debug
setenv mpirunCommand  "mpirun -np"
          </code></pre>
        </section>

        <section>
          <h3><code>mkmf.template.ia64 header</code></h3>
          <pre><code data-trim class="csh">
CPPFLAGS =
FFLAGS_BASE = -v -V -what -fpp -fno-alias -stack_temps -safe_cray_ptr -ftz -i_dynamic -assume
 byterecl -g -i4 -r8 -Wp,-w
FFLAGS_REPRO = -fltconsistency
FFLAGS_DEBUG = -check -check noarg_temp_created -check nopointer -warn -warn noerrors -debug
variable_locations -inline_debug_info -fpe0 -traceback -ftrapuv
FFLAGS = $(FFLAGS_BASE) -O2 -nowarn
FC = ifort
CC = icc
CFLAGS_BASE = -g -D__IFC
CFLAGS_DEBUG = -ftrapuv -traceback
CFLAGS = $(CFLAGS_BASE) -O2
LD = ifort
LDFLAGS = -Wl,-V,--verbose,-cref,-Map linker.map -lnetcdf -lmpi -lsma
MAKEFLAGS+=--jobs=8
          </code></pre>
        </section>

        <section>
          <h3>Compilation</h3>
          <p>Use the <code>MOM_compile.csh</code> script:
          <pre><code data-trim>
cd exp
./MOM_compile --type MOM_SIS --platform nci
          </code></pre>
          Executable is located here:
          <pre><code class="sh" data-trim>
${CODEBASE}/exec/${platform}/${type}/fms_${type}.x
          </code></pre>
        </section>

        <!-- Usage -->

        <section>
          <h2>Running MOM</h2>
        </section>

        <section>
          <h3>Experiment layout</h3>
          <dl>
            <dt><code>./</code></dt>
            <dd>Configuration files (namelists, etc.)</dd>
            <dt><code>INPUT/</code></dt>
            <dd>Grid data, forcings, input restarts</dd>
            <dt><code>RESTART/</code></dt>
            <dd>Output restart files (initially empty)</dd>
          </dl>
        </section>

        <section>
          <h3>Configuration files</h3>
          <p>Four basic configuration files:<p>
          <dl>
            <dt><code>input.nml</code></dt>
              <dd>Main configuration namelist</dd>
            <dt><code>diag_table</code></dt>
              <dd>Diagnostic fields and output rates</dd>
            <dt><code>data_table</code></dt>
              <dd>External data sets (boundary conditions)</dd>
            <dt><code>field_table</code></dt>
              <dd>Supplemental configuration</dd>
          </dl>
        </section>

        <section>
          <h3>Mosaic grid system</h3>

          <dl>
            <dt><code>grid_spec.nc</code></dt>
            <dd>Top-level mosaic (metadata) file</dd>
            <dt><code>ocean_mosaic.nc</code></dt>
            <dd>Submodel mosaic: atmosphere, ocean, land</dd>
            <dt><code>ocean_hgrid.nc</code></dt>
            <dd>Horizontal grid for each submodel</dd>
            <dt><code>ocean_topog.nc</code></dt>
            <dd>Ocean bathymetry</dd>
          </dl>
        </section>

        <section>
          <h3>Additional inputs</h3>

          <dl>
            <dt><code>atm_ocean_mosaic_tile1Xocn_ocean_mosaic_tile1.nc</code></dt>
            <dd>Coupling maps between submodels</dd>
            <dt><code>land_mask.nc</code>, <code>ocean_mask.nc</code></dt>
            <dd>Mask maps for land and ocean</dd>
            <dt><code>ocean_vgrid.nc</code></dt>
            <dd>MOM's vertical grid</dd>
          </dl>
        </section>

        <section>
          <h3>Input fields</h3>
          <p>Defined in <code>data_table</code></p>
          <pre><code data-trim class="sh">
"ATM", "p_surf", "SLP", "./INPUT/slp.nc", "bicubic", 1.0
"ATM", "p_bot", "SLP", "./INPUT/slp.nc", "bicubic", 1.0
"ATM", "t_bot", "T_10_MOD" , "./INPUT/t_10.nc", "bicubic" ,  1.0
"ATM", "sphum_bot", "Q_10_MOD" , "./INPUT/q_10.nc", "bicubic" , 1.0
"ATM", "u_bot", "U_10_MOD", "./INPUT/u_10.nc", "bicubic",  1.0
"ATM", "v_bot", "V_10_MOD", "./INPUT/v_10.nc", "bicubic",  1.0
"ATM", "z_bot", "", "", "bicubic", 10.0
"ATM", "gust", "", "", "bicubic", 0.0
"ICE", "lw_flux_dn", "LWDN_MOD", "./INPUT/ncar_rad.nc", "bicubic", 1.0
#"ICE", "sw_flux_dn", "SWDN_MOD" ,"./INPUT/ncar_rad.nc", "bicubic", 1.0
"ICE" , "sw_flux_vis_dir_dn", "SWDN_MOD", "./INPUT/ncar_rad.nc", "bicubic", 0.285
"ICE" , "sw_flux_vis_dif_dn", "SWDN_MOD", "./INPUT/ncar_rad.nc", "bicubic", 0.285
          </code></pre>
          <p>Format:
          <pre><code data-trim class="sh">
submodel, var_name, field_name, filepath, interp_method, scaling
          </code></pre>
        </section>

        <section>
          <h3>Diagnostic output</h3>
          <pre><code data-trim class="sh">
MOM4p1_CORE_IAF_v20120531_0849_noRestore_runoff_fix
1 1 1 0 0 0
"ocean",        5, "days",   1, "days", "time",
"ocean_daily", 24, "hours",  1, "days", "time",
"ocean_grid",  -1, "months", 1, "days", "time",
#=================================================================
"ocean_model","geolon_t","geolon_t","ocean","all",.false.,"none",2
"ocean_model","geolat_t","geolat_t","ocean","all",.false.,"none",2
"ocean_model","geolon_c","geolon_c","ocean","all",.false.,"none",2
"ocean_model","geolat_c","geolat_c","ocean","all",.false.,"none",2
"ocean_model","temp","temp",        "ocean","all",.true.,"none",2
"ocean_model","salt","salt",        "ocean","all",.true.,"none",2
"ocean_model","u","u",              "ocean","all",.true.,"none",2
"ocean_model","v","v",              "ocean","all",.true.,"none",2
          </code></pre>
          <p>Format:
          <pre><code data-trim class="sh">
file, out_rate, out_units, format, axis_units, axis_name
#=================================================================
module, var_name, out_name, file, "all", average, region, format
          </code></pre>
        </section>

        <section>
          <h3>Tracer advection</h3>
          <p>Advection scheme for each tracer defined in
          <code>field_table</code>:</p>
          <pre><code data-trim class="fortran">
"prog_tracers","ocean_mod","temp"
horizontal-advection-scheme = mdppm
vertical-advection-scheme = mdppm
restart_file  = ocean_temp_salt.res.nc
ppm_hlimiter = 3
ppm_vlimiter = 3
/
          </code></pre>
        </section>

        <section>
          <h3>Experiment runtime</h3>
          <p>Set in <code>input.nml</code>:
          <pre><code data-trim class="fortran">
&amp;coupler_nml
    date_init = 1980,1,1,0,0,0
    months = 0
    days = 2
    hours = 0
    minutes = 0
    seconds = 0
    calendar = 'julian'
    dt_cpld  = 86400
/
          </code></pre>
          <ul>
            <li>Largest nonzero date used</li>
            <li>Gregorian, Julian, noleap, and 360day calendars</li>
            <li><code>MOM_solo</code> uses <code>ocean_solo_nml</code></li>
          </ul>
        </section>

        <!-- Model configuration -->

        <section>
          <h2>Troubleshooting</h2>
        </section>

        <section>
          <h3>Tuning and configuring models</h3>
          <ul>
            <li>This is usually a <i>very hard problem</i></li>
            <li>Most problems come down to numerical instability</li>
            <li>Coupled instabilites usually appear like this:</li>
          </ul>
          <pre><code data-trim>
lookup_es: saturation vapor pressure table overflow, nbad=      1
          </code></pre>
          <p>due to blowup of other variables (e.g. temperature)</p>
        </section>

        <section>
          <h3>Timesteps</h3>
          <p>Explicit timesteps parallelise well, but they are inherently
             unstable</p>
          <pre><code data-trim class="fortran">
&amp;ocean_model_nml
    dt_ocean = 10800
    vertical_coordinate = 'zstar'
    time_tendency = 'twolevel'
    baroclinic_split = 1
    surface_height_split = 1
    barotropic_split = 60
/
          </code></pre>
          <p>First try reducing your timesteps</p>
          </code></pre>
        </section>

        <section>
          <h3>Viscosities</h3>
          <ul>
            <li>Turbulent systems push energy to small scales</li>
            <li>... which are aliased to large scales (unstable)</li>
          </ul>
          <pre><code data-trim class="fortran">
&amp;ocean_lap_friction_nml
  ! lap_friction_scheme='const'
  lap_friction_scheme='general'
/

&amp;ocean_lapcst_friction_nml
  use_this_module=.false.
  alap = 1e4
/

&amp;ocean_lapgen_friction_nml
  use_this_module=.true.
  k_smag_iso=2.0
  vel_micom_iso=0.005
/
          </code></pre>
          <p>Note: Biharmonic ($-\nabla^4$) viscosities are preferred</p>
        </section>

        <section>
          <h3>Feedbacks</h3>
          <p>Physical processes can yield unstable responses:
          <ul>
            <li>Sea ice melt</li>
            <li>River runoff</li>
            <li>Accumulation in narrow straits</li>
            <li>Evaporation in shallow seas</li>
          </ul>
          <p>Many parameterisations also have inherent numerical
          instabilities</p>
          <p>At this point, you're on your own...</p>
        </section>

        <!-- Communication -->

        <section>
          <h2>MOM communication</h2>
        </section>

        <section>
          <h3>Point-to-point</h3>
          <dl>
            <dt><code>mpp_send</code></dt>
            <dd>Queues and calls <code>MPI_Isend</code></dd>
            <dt><code>mpp_recv</code></dt>
            <dd>Queues and calls <code>MPI_Recv</code></dd>
            <dt><code>mpp_sync_self</code></dt>
            <dd>Calls <code>MPI_Wait</code> for queued requests</dd>
          </dl>
          <p>Buffered calls are optional, and messages can be combined</p>
          <p>(See <code>src/shared/mpp/mpp_transmit.inc</code>)</p>
        </section>

        <section>
          <h3>Point-to-point example</h3>
          <pre><code data-trim class="fortran">
if (myid_y &lt; size_y) then
   do ii = myid_y + 1, size_y
      call mpp_send(psiu2(isc:iec), lenx, pelist_y(ii))
   end do
end if
call mpp_sync_self()

if(myid_y &gt; 1) then
  do ii = 1, myid_y - 1
    call mpp_recv(psiu2(isc:iec), lenx, pelist_y(ii))
    do i=isc, iec; do j=jsc, jec
      psiu(i,j) = psiu(i,j) + psiu2(i)
    end do; end do
  end do
end if
          </code></pre>
        </section>

        <section>
          <h3>Collectives</h3>
          <dl>
            <dt>mpp_sum</dt>
            <dd>Sum over ranks</dd>
            <dt>mpp_max</dt>
            <dd>Maximum value over ranks</dd>
            <dt>mpp_min</dt>
            <dd>Minimum value over ranks</dd>
          </dl>
          <p>Wrappers to <code>MPI_Allreduce</code></p>
        </section>

        <section>
          <h3>Collective example</h3>
          <pre><code data-trim class="fortran">
! Calculate total potential energy
pe_tot = 0.
do k= 1, nk
  do j = jsc, jec
    do i = isc, iec
      pe_tot = pe_tot + Grd%dat(i, j) * Thickness%dzt(i, j, k) &
              * Dens%rho(i, j, k, taup1) * Grd%tmask(i, j, k) &
              * Thickness%depth_zt(i, j, k) * grav
    end do
  end do
end do
call mpp_sum(pe_tot)
          </code></pre>
        </section>

        <section>
          <h3>Other comms</h3>
          <dl>
            <dt><code>mpp_global_field</code></dt>
            <dd>Gather global scalar or vector field onto rank</dd>
            <dt><code>mpp_chksum</code></dt>
            <dd>Call <code>mpp_sum</code> as 8-byte integer recast</dd>
          </dl>
        </section>

        <section>
          <h3>Generic interfaces</h3>
          <p>Interfaces have been provided for all cases</p>
           <pre><code data-trim class="fortran">
interface mpp_sum
    module procedure mpp_sum_int8
    module procedure mpp_sum_int8_2d
    module procedure mpp_sum_int8_3d
    module procedure mpp_sum_int8_4d
    module procedure mpp_sum_int8_5d

    module procedure mpp_sum_real8
    module procedure mpp_sum_real8_2d
    !...
end interface mpp_sum
          </code></pre>
          <ul>
            <li>Scalars and vectors (2d, 3d, 4d, 5d)</li>
            <li>Integers, reals, and complex types</li>
            <li>4 and 8 bytes</li>
          </ul>
        </section>

        <section>
          <h3>Domain stacks</h3>
          <p>Most <code>mpp</code> operations use an internal stack:<p>
          <pre><code data-trim class="fortran">
&amp;fms_nml
  domains_stack_size = 115200
/
          </code></pre>
          <p>MOM automatically sets this to tile size, but SIS does not</p>
        </section>

        <!-- Grid domains -->

        <section>
          <h3>MOM grids</h3>
        </section>

        <section>
          <h3>Grid domain decomposition</h3>
          <img src="figures/tiling.svg" alt="MOM tiling illustration">
        </section>

        <section>
          <h3>Layout configuration</h3>
          <pre><code data-trim class="fortran">
&amp;ice_model_nml
  layout = 32, 30
  io_layout = 1, 30
/
&amp;ocean_model_nml
  layout = 32, 30
  io_layout = 1, 30
/
          </code></pre>
          <p>Output files can contain multiple tiles</p>
        </section>

        <section>
          <h3>Halo update</h3>
          <img src="figures/halo.svg" alt="Halo update"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Grid indexing</h3>
          <dl>
            <dt>Global domain</dt>
            <dd><code>isg, ieg, jsg, jeg</code></dd>
            <dt>Compute domain</dt>
            <dd><code>isc, iec, jsc, jec</code></dd>
            <dt>Data domain</dt>
            <dd><code>isd, ied, jsd, jed</code></dd>
            <dt>Memory domain</dt>
            <dd><code>ism, iem, jsm, jem</code></dd>
          </ul>
        </section>

        <section>
          <h3>Grid API</h3>
          <dl>
            <dt><code>mpp_define_domains</code></dt>
            <dd>Set up the domain decomposition</dd>
            <dt><code>mpp_get_data_domain</code></dt>
            <dd>Get data domain indices</dd>
            <dt><code>mpp_get_compute_domain</code></dt>
            <dd>Get compute domain indices</dd>
            <dt><code>mpp_update_domains</code></dt>
            <dd>Stage a halo update</dd>
          </dl>
        </section>

        <section>
          <h3>Domain API example</h3>
          <pre><code data-trim class="fortran">
call mpp_define_domains([1, 100], 2, domain, pelist, halo=2)

call mpp_get_global_domain(domain, isg, ieg)  ! isg, ieg = -1, 102
call mpp_get_data_domain(domain, isd, ied)    ! isd, ied = -1, 52
call mpp_get_compute_domain(domain, isc, iec) ! isc, iec = 1, 50

allocate(a(isd:ied))
do i = isc, iec
    a(i) = &lt;perform computations&gt;
end do
call mpp_update_domains(a, domain)
          </code></pre>
        </section>

        <section>
          <h3>Miscellaneous</h3>
        </section>

        <section>
          <h3>Internal profiler</h3>
          <dl>
            <dt>mpp_clock_id</dt>
            <dd>Define a new clock</dd>
            <dt>mpp_clock_begin</dt>
            <dd>Start timer</dd>
            <dt>mpp_clock_end</dt>
            <dd>Stop timer</dd>
          </dl>
          <p>Based on <code>system_clock</code></p>
        </section>

        <section>
          <h3>Profiler example</h3>
          <pre><code data-trim class="fortran">
initClock = mpp_clock_id('Init')
call mpp_clock_begin(initClock)

call fms_init
call constants_init
call coupler_init

call mpp_set_current_peset()

call mpp_clock_end(initClock)
          </code></pre>
          <p>Report in standard out:</p>
          <pre><code data-trim>
.     tmin    tmax    tavg    tstd   tfrac  grain  pemin pemax
Init  41.135  41.142  41.139  0.002  0.154  0      0     959
          </code></pre>
        </section>

        <section>
          <h3>Bit reproducibility</h3>
          <p>MOM is largely bit reproducible, with a few conditions:
          <ul>
            <li>Collectives (e.g. <code>mpp_sum</code> are
              <i>not</i> reproducible!</li>
            <li>Dynamic parts requiring collectives will have special flags:
              <pre><code data-trim class="fortran">
&ocean_sbc_nml
    do_bitwise_exact_sum=.true.
/
              </code></pre>
              Note that these are generally much slower
            </li>
            <li>Diagnostics using collectives are generally not
              reproducible</li>
            <li>Raijin required this compiler flag:
              <pre><code data-trim class="fortran">
mpifort &lt;...&gt; -align all
              </code></pre>
              probably due to int4 vs real8 alignment
            </li>
          </ul>
        </section>

        <section>
          <h3>Bit reproducibility across layouts</h3>
          <p>Reproducibility for different tiles is generally <i>never</i>
            reproducible, with a few exceptions</p>
          <li>Coupler flux exchange can be made independent of layout:
            <pre><code data-trim class="fortran">
&xgrid_nml
  make_exchange_reproduce=.true.
/
            </code></pre>
            Note that this is very slow!
          </li>
        </section>

        <!--
        <section>
          <h3>Checksums</h3>
          <ul>
            <li><code>debug_this_module = .true.</code></li>
          </ul>
        </section>
        -->

        <section>
          <h3>Diagnostics</h3>
          <dl>
            <dt><code>register_diag_field</code></dt>
            <dd>Register the diagnostic, return an ID</dd>
            <dt><code>send_data</code></dt>
            <dd>Send data to diagnostic manager</dd>
            <dt><code>diagnose_{2d,3d}{,_u}</code></dt>
            <dd>Wrapper to <code>send_data</code> for masked fields</dd>
          </dl>
        </section>

        <section>
          <h3>Diagnostics example</h3>
          <pre><code data-trim class="fortran">
id_u(1) = register_diag_field ('ocean_model', 'u', &
              Grd%vel_axes_u(1:3), Time%model_time, &
              'i-current', 'm/sec', &
              missing_value=missing_value, &
              range=(/-10.0,10.0/), &
              standard_name='sea_water_x_velocity')

call diagnose_3d_u(Time, Grd, id_u(1), Velocity%u(:,:,:,1,tau))

if (id_u(1) > 0) used = send_data (id_u(1), &
                         Velocity%u(:,:,:,1,tau), &
                         Time%model_time, rmask=Grd%mask(:,:,:), &
                         is_in=isc, js_in=jsc, ks_in=1, &
                         ie_in=iec, je_in=jec, ke_in=nk)
          </code></pre>
        </section>

        <!-- Tracer update -->

        <section>
          <h2>Subroutine overview</h2>
        </section>

        <section>
          <h3>Relative breakdown</h3>
          <img src="figures/pie.svg"
               alt="Subroutine breakdown"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Tracer advection</h3>
          <img src="figures/subrt/update_ocean_tracer.svg"
               alt="Tracer update scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <section>
            <h3>Tracer fields</h3>
            <p>Temperature, salinity, submerged time ("age"), ...</p>

            <ul>
              <li><code>update_ocean_tracer</code>
                <ul>
                  <li><code>horz_advect_tracer</code>
                    <ul>
                      <li><code>advect_tracer_mdppm</code>
                        <ul>
                          <li><code>ppm_limit_sh</code></li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li><code>vert_diffuse_implicit</code></li>
                  <li><code>send_tracer_diagnostics</code></li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h3>Tracer advection</h3>
            <img src="figures/subrt/horz_advect_tracer.svg"
                 alt="Horizontal tracer advection scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>MDPPM tracer advection</h3>
            <img src="figures/subrt/advect_tracer_mdppm.svg"
                 alt="MDPPM tracer advection scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>PPM limit</h3>
            <img src="figures/subrt/ppm_limit_sh.svg"
                 alt="PPM limit scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Implicit vertical diffusion</h3>
            <img src="figures/subrt/vert_diffuse_implicit.svg"
                 alt="Implicit vertical diffusion scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Tracer diagnostics</h3>
            <img src="figures/subrt/send_tracer_diagnostics.svg"
                 alt="Tracer diagnostic scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>
        </section>

        <!--
        <section>
          <h3>MDPPM advection</h3>
          <p>TODO</p>
        </section>
        -->

        <section>
          <h3>Time-implicit vertical diffusion</h3>
          <p>Uses a tridiagonal solver</p>
          <p>TODO</p>
        </section>

        <!-- Velocity update -->

        <section>
          <h3>Acceleration</h3>
          <img src="figures/subrt/ocean_explicit_accel_a.svg"
               alt="Acceleration scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <section>
            <h3>Acceleration call tree</h3>
            <ul>
              <li><code>ocean_explicit_accel_a</code></li>
                <ul>
                  <li><code>bih_friction</code></li>
                  <li><code>pressure_force</code></li>
                  <li><code>horz_advection_of_velocity</code></li>
                  <li><code>vert_advection_of_velocity</code></li>
                  <li><code>momentum_source</code></li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h3>Biharmonic friction</h3>
            <img src="figures/subrt/bih_friction.svg"
                 alt="Biharmonic friction scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Pressure</h3>
            <img src="figures/subrt/pressure_force.svg"
                 alt="Pressure force scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Horizontal momentum advection</h3>
            <img src="figures/subrt/horz_advection_of_velocity.svg"
                 alt="Horizontal advection of velocity scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Vertical momentum advection</h3>
            <img src="figures/subrt/vert_advection_of_velocity.svg"
                 alt="Vertical advection of velocity scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Momentum sources</h3>
            <img src="figures/subrt/momentum_source.svg"
                 alt="Momentum source scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>
        </section>

        <!--
        <section>
          <h3>Biharmonic operator</h3>
          <p>TODO</p>
        </section>
        -->

        <!-- Vertical mixing -->

        <section>
          <h3>Vertical mixing coefficient</h3>
          <img src="figures/subrt/vert_mix_coeff.svg"
               alt="Vertical mixing scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <section>
            <h3>Vertical mixing call tree</h3>
            <ul>
              <li>vert_mix_coeff</li>
                <ul>
                  <li>vert_mix_kpp_mom4p1</li>
                  <li>vert_mix_tidal</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h3>KPP vertical mixing</h3>
            <img src="figures/subrt/vert_mix_kpp_mom4p1.svg"
                 alt="KPP scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Tidal mixing</h3>
            <img src="figures/subrt/vert_mix_tidal.svg"
                 alt="Tidal mixing scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>
        </section>

        <!-- Submesoscale restratification -->

        <section>
          <h3>Submesoscale restratification</h3>
          <img src="figures/subrt/submeso_restrat.svg"
               alt="Submeso scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <section>
            <h3>Submesoscale call tree</h3>
            <ul>
              <li>submeso_restrat</li>
                <ul>
                  <li>compute_submeso_skewsion</li>
                  <li>compute_psi</li>
                  <li>compute_bldepth</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h3>Submesoscale skew diffusion</h3>
            <img src="figures/subrt/compute_submeso_skewsion.svg"
                 alt="Skewsion scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Mesoscale streamfunction</h3>
            <img src="figures/subrt/compute_psi.svg"
                 alt="Barotropic streamfunction scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>

          <section>
            <h3>Boundary layer depth</h3>
            <img src="figures/subrt/compute_bldepth.svg"
                 alt="boundary layer depth"
                 style="background: none; border: none; box-shadow: none;">
          </section>
        </section>

        <!--
        <section>
          <h3>Submesoscale theory</h3>
          <ul>
            <li>Parameterises the restratification by mesoscale eddies</li>
            $$\Psi = \left( \frac{C_e \mu h^2 g \Delta s}
            {\rho_0 L_f \sqrt{f^2 + \tau^{-2}}} \right)
            \hat{\mathbf{z}} \times \overline{\nabla \gamma}$$
          </ul>
          <p>TODO</p>
        </section>
        -->

        <!-- Barotropic update -->

        <section>
          <h3>Barotropic surface update</h3>
          <img src="figures/subrt/update_ocean_barotropic.svg"
               alt="Acceleration scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <section>
            <h3>Barotropic call tree</h3>
            <ul>
              <li>update_ocean_barotropic</li>
                <ul>
                  <li>pred_corr_tropic_depth_bgrid</li>
                </ul>
              </li>
            </ul>
          </section>

          <section>
            <h3>Tropic depth predictor/corrector</h3>
            <img src="figures/subrt/pred_corr_tropic_depth_bgrid.svg"
                 alt="Tropic depth predictor/corrector scaling"
                 style="background: none; border: none; box-shadow: none;">
          </section>
        </section>

        <section>
          <h3>Barotropic solver</h3>
          <ul>
            <li>Predictor-corrector (Euler) timesteps</li>
            <li>80 barotropic steps per ocean (baroclinic) step</li>
            <li>Halos updated every 10 BT timesteps</li>
            <li>42 halo updates per ocean step</li>
          </ul>
          <p>Basic equation:
$$\begin{align}
\rho_o \left(\partial_t + f \hat{z} \times \right) \mathbf{U} &= \mathbf{G}
    - \left( H + \eta \right) \nabla \left( \rho_a + \rho_0 g \eta \right) \\
\eta_t &= - \nabla \cdot \mathbf{U}
\end{align}$$
          </p>
        </section>

        <section>
          <h3>Density update</h3>
          <img src="figures/subrt/update_ocean_density.svg"
               alt="Density update scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Implicit acceleration</h3>
          <img src="figures/subrt/ocean_implicit_accel.svg"
               alt="Implict acceleration scaling"
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>U-cell thickness update</h3>
          <img src="figures/subrt/update_ucell_thickness.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Ocean surface smoothing</h3>
          <img src="figures/subrt/ocean_eta_smooth.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Ocean surface smoothing</h3>
          <ul>
            <li>Required to remove B-grid null mode</li>
            <li>Using biharmonic, Laplacian is recommended</li>
            <li>C-grid doesn't need this</li>
          </ul>
          <p>Basic filtering:
          $$\eta_{n+1} = -\nabla^4 \eta_n$$
          </p>
        </section>

        <section>
          <h3>Shortwave radiation source</h3>
          <img src="figures/subrt/sw_source.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Velocity update</h3>
          <img src="figures/subrt/update_ocean_velocity_bgrid.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Velocity advection</h3>
          <img src="figures/subrt/ocean_advection_velocity.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>T-cell thickness update</h3>
          <img src="figures/subrt/update_tcell_thickness.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Density diagnostics</h3>
          <img src="figures/subrt/ocean_density_diag.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>Surface boundary conditions</h3>
          <img src="figures/subrt/get_ocean_sbc.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <section>
          <h3>General diagnostics</h3>
          <img src="figures/subrt/ocean_diagnostics.svg"
               alt=""
               style="background: none; border: none; box-shadow: none;">
        </section>

        <!-- Future work -->
        <section>
          <h3>Focus for the future</h3>
          <ul>
            <li>Barotropic solver and filter</li>
            <li>Tracer advection</li>
            <li>Biharmonic viscosity</li>
            <li>Diagnostics</li>
            <li>Initialization runtime</li>
            <li>Fix these functions:
              <ul>
                <li><code>mpp_global_field</code></li>
                <li><code>psi_compute</code></li>
                <li><code>ncar_rescale</code></li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>psi_compute</h3>
          <p><img src="figures/streamfunction.svg"
                  style="float: left; width: 60%;"
                  alt="Streamfunction messages">
          </p>
          <p>Integration of
            $$\psi = \int_0^y u dy$$
          for tile must collect
          values to the south</p>
          <p style="clear: both;">$N_\text{msg} \approx \frac{1}{2} N_x N_y^2$</p>
        </section>

        <!-- configuration -->

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
          Reveal.initialize({
            dependencies: [
              { src: 'plugin/highlight/highlight.js',
                async: true,
                condition: function() {
                  return !!document.querySelector( 'pre code' ); },
                callback: function() {
                  hljs.initHighlightingOnLoad(); }
              },

              { src: 'plugin/math/math.js', async: true }
            ]
          });
        </script>
      </div>
    </div>
</html>
